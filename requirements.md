# Signal — 要求仕様書

## 1. プロダクト概要

### 1.1 プロダクト名

Signal

### 1.2 コンセプト

インターネット接続・サーバー・追加機材を一切使わず、スマートフォンのブラウザが持つ物理的な入出力（スピーカー/マイク、画面/カメラ）のみを利用して、近くにいる人とテキストメッセージをやり取りするモバイルWebアプリケーション。

### 1.3 ターゲットユーザー

- 物理信号を使った通信に興味のある技術愛好家
- オフライン環境で簡易的にメッセージ交換をしたい人

### 1.4 動作環境

| 項目 | 要件 |
|------|------|
| 対象デバイス | スマートフォン（iOS / Android） |
| 対象ブラウザ | Chrome（Android）、Safari（iOS）の最新版 |
| 必須ブラウザAPI | Web Audio API、getUserMedia（audio/video）、Canvas API |
| ホスティング | HTTPS環境（カメラ・マイクの利用に必須） |
| ネットワーク | アプリ配信時のみ必要。チャット通信自体はオフラインで動作 |

---

## 2. 通信チャネル仕様

本アプリは以下の6つの物理通信チャネルを実装する。すべてのチャネルは追加機材不要で、主要モバイルブラウザで動作するブラウザAPIのみを使用する。

### 2.1 チャネル一覧

| ID | 名称 | 送信手段 | 受信手段 | 物理媒体 |
|----|------|----------|----------|----------|
| `ultrasonic` | 超音波 | Web Audio API（スピーカー） | getUserMedia + AnalyserNode（マイク） | 18–19kHz の空気振動 |
| `audible` | 可聴音 | Web Audio API（スピーカー） | getUserMedia + AnalyserNode（マイク） | 800–1600Hz の空気振動 |
| `brightness` | 画面明滅 | Canvas / CSS（画面の白黒切替） | getUserMedia(video) + Canvas解析（カメラ） | 可視光（輝度変化） |
| `color` | 色変調 | Canvas / CSS（画面の赤緑切替） | getUserMedia(video) + Canvas解析（カメラ） | 可視光（色相変化） |
| `grid` | 空間グリッド | Canvas（4×4のグリッド表示） | getUserMedia(video) + Canvas解析（カメラ） | 可視光（空間分割） |
| `qr` | QRストリーミング | Canvas（QRコード表示） | getUserMedia(video) + QRコード認識（カメラ） | 可視光（QRコード） |

### 2.2 超音波チャネル（`ultrasonic`）

#### 概要

人間にほぼ聞こえない18kHz〜19kHz帯の音波を使ったFSK（Frequency Shift Keying）変調による通信。

#### パラメータ

| パラメータ | 値 | 説明 |
|------------|-----|------|
| パイロット周波数 | 17,000 Hz | 通信開始を示すトーン |
| ビット0の周波数 | 18,000 Hz | |
| ビット1の周波数 | 19,000 Hz | |
| 1ビットあたりの発信時間 | 100 ms | |
| ビット間のガード区間 | 8 ms | |
| パイロット信号の検出閾値 | -42 dB | FFTパワースペクトルでの判定値 |
| FFTサイズ | 8192 | 周波数分解能の確保用 |

#### 送信フロー

1. AudioContextを生成する
2. パイロット周波数（17kHz）を700ms間発信する
3. 300msの無音ギャップを入れる
4. ビット列を1ビットずつ、0なら18kHz、1なら19kHzのトーンを100ms発信する
5. 各ビットの間に8msのガード区間を入れる
6. 全ビット送信後、AudioContextを閉じる

#### 受信フロー

1. getUserMedia(audio)でマイクを取得する
2. AnalyserNodeを接続し、FFTサイズ8192、smoothingTimeConstant 0.3に設定する
3. パイロット周波数帯のパワーが閾値を超えるまで待機する（idle状態）
4. パイロットを検出したら、パイロットが消えるのを待つ（pilot状態）
5. パイロットが消えてから300ms×0.6以上経過したら、ビット受信を開始する（gap→bits状態）
6. bitMs+8ms間隔でFFTパワーを取得し、freq0とfreq1のパワーを比較してビットを判定する
7. 16ビット目（プリアンブル8ビット＋開始マーカー8ビット）以降でデータ長を読み取り、必要なビット数が揃ったらデコードする
8. デコード後、idle状態に戻り次のメッセージを待つ

#### ビジュアライゼーション

受信中は、FFTスペクトルをリアルタイムで棒グラフとして描画する。パイロット・freq0・freq1に該当する周波数帯をハイライト表示する。

### 2.3 可聴音チャネル（`audible`）

#### 概要

可聴域の800Hz〜1600Hzを使ったFSK変調による通信。モデム風の音が鳴る。超音波より帯域幅が大きく高速だが、人間に聞こえる。

#### パラメータ

| パラメータ | 値 |
|------------|-----|
| パイロット周波数 | 400 Hz |
| ビット0の周波数 | 800 Hz |
| ビット1の周波数 | 1,600 Hz |
| 1ビットあたりの発信時間 | 70 ms |
| ビット間のガード区間 | 8 ms |
| 検出閾値 | -40 dB |
| FFTサイズ | 8192 |

#### 送受信フロー

超音波チャネルと同一のロジック。周波数とタイミングパラメータのみ異なる。

### 2.4 画面明滅チャネル（`brightness`）

#### 概要

送信側の画面全体を白（ビット1）と黒（ビット0）に交互に切り替え、受信側のカメラで輝度変化を検出する。

#### パラメータ

| パラメータ | 値 |
|------------|-----|
| 1ビットあたりの表示時間 | 250 ms |
| パイロット | 画面全体を白で700ms表示 |
| 輝度判定閾値 | キャリブレーション値 + 40 |

#### 送信フロー

1. 全画面オーバーレイを表示する
2. 画面全体を白（#FFFFFF）で700ms表示（パイロット）
3. 画面全体を黒（#000000）で300ms表示（ギャップ）
4. ビット列を1ビットずつ、1なら白、0なら黒で250ms表示する
5. 全ビット送信後、黒を200ms表示してオーバーレイを閉じる

#### 受信フロー

1. getUserMedia(video)でカメラ（フロントカメラ）を取得する
2. 500msの安定待ち後、現在の平均輝度をベースラインとしてキャリブレーションする
3. 輝度がベースライン+60を超えたらパイロットとして検出する
4. 以降はBitReceiverの汎用ロジックでビットを受信する（輝度が閾値を超えたら1、以下なら0）

#### ビジュアライゼーション

受信中はカメラの映像をシグナルパネル内のCanvasにリアルタイムで描画する。

### 2.5 色変調チャネル（`color`）

#### 概要

送信側の画面全体を赤（ビット0）と緑（ビット1）に切り替え、受信側のカメラでRGBの比率を解析して色を判別する。

#### パラメータ

| パラメータ | 値 |
|------------|-----|
| 1ビットあたりの表示時間 | 280 ms |
| ビット0の色 | #FF0000（赤） |
| ビット1の色 | #00FF00（緑） |
| パイロット色 | #0000FF（青） |
| パイロット検出条件 | 青チャネル値 > 100 かつ 青 > 赤×1.3 かつ 青 > 緑×1.3 |

#### 送信フロー

1. 全画面オーバーレイを表示する
2. 画面全体を青（#0000FF）で700ms表示（パイロット）
3. 画面全体を黒（#000000）で300ms表示（ギャップ）
4. ビット列を1ビットずつ、0なら赤、1なら緑で280ms表示する
5. 全ビット送信後、黒を200ms表示してオーバーレイを閉じる

#### 受信フロー

1. カメラを取得し、キャリブレーション待ちを行う
2. カメラ映像の中央領域のRGB平均値を計算する
3. 青が支配的であればパイロットとして検出する
4. データ受信中は、緑 > 赤なら1、赤 > 緑なら0と判定する

#### 中央領域サンプリング

カメラ映像の中央20%の正方形領域内のピクセルを2ピクセル間隔でサンプリングし、RGBの平均値を算出する。

#### ビジュアライゼーション

カメラ映像をCanvasに描画し、右上に現在検出中の色をカラーチップとして表示する。

### 2.6 空間グリッドチャネル（`grid`）

#### 概要

画面を4×4のグリッドに分割し、各セルを白（1）または黒（0）にすることで1フレームあたり16ビットを並列送信する。カメラで各セルの輝度を個別に認識する。

#### パラメータ

| パラメータ | 値 |
|------------|-----|
| グリッドサイズ | 4行 × 4列 = 16セル |
| 1フレームあたりのビット数 | 16ビット（2バイト） |
| 1フレームの表示時間 | 400 ms |
| パイロット | 全セル白で800ms表示 |
| 終了マーカー | チェッカーボードパターン |

#### データフレーミング

プロトコルのビット列ではなく、独自のバイト単位フレーミングを使用する。

1. ペイロード構造: `[データ長(1byte), データ本体(N bytes), XORチェックサム(1byte)]`
2. ペイロードが奇数バイトの場合は末尾に0x00をパディングし、偶数バイトに揃える
3. 1フレームで2バイト（16ビット）を送信する。上位バイトがセル0-7、下位バイトがセル8-15に対応する

#### 送信フロー

1. 全画面オーバーレイを表示する
2. 全セル白で800ms表示（パイロット）
3. 全セル黒で400ms表示（ギャップ）
4. 2バイトずつフレームに分割し、各フレームを400ms表示する
5. 最後にチェッカーボードパターン（(row + col) % 2）を500ms表示（終了マーカー）
6. オーバーレイを閉じる

#### 受信フロー

1. カメラを取得し安定を待つ
2. 全セルが輝度150超（全白）になったらパイロットとして検出する
3. 全白でなくなったらギャップ開始、250ms以上経過したらデータ受信に遷移する
4. フレーム間隔（frameMs × 0.75）ごとにグリッドの各セルの輝度を読み取り、128超なら1、以下なら0とする
5. チェッカーボードパターンを検出したら終了。チェッカーボード判定は75%以上の一致で許容する（環境ノイズ耐性）
6. 受信したフレームからバイト列を復元し、データ長・チェックサムを検証してメッセージを取り出す

#### セル輝度サンプリング

各セルの中心点を基準に、セルサイズの25%の範囲を2ピクセル間隔でサンプリングし、RGB平均輝度を算出する。

### 2.7 QRストリーミングチャネル（`qr`）

#### 概要

メッセージ全体をQRコードにエンコードして画面に表示し、受信側のカメラでQRコードを読み取る。エラー訂正機能があり、最も信頼性が高い。

#### パラメータ

| パラメータ | 値 |
|------------|-----|
| QRエラー訂正レベル | M（15%復元可能） |
| QRコード表示サイズ | 画面短辺の85% |
| 表示時間 | 3,000 ms |
| 背景色 | #FFFFFF |

#### 送信フロー

1. 全画面オーバーレイを表示する
2. メッセージをQRコードにエンコードする（ライブラリ使用）
3. 画面中央にQRコードを白背景で3秒間表示する
4. オーバーレイを閉じる

#### 受信フロー

1. カメラを取得する
2. requestAnimationFrameループで毎フレーム、カメラ映像からQRコードの検出を試みる
3. QRコードが検出され、前回と異なるデータであれば受信メッセージとして処理する
4. 検出時、QRコードの四隅の座標をビジュアライザに緑色の枠で表示する

#### 依存ライブラリ

| ライブラリ | 用途 |
|------------|------|
| qrcode-generator | QRコード生成（送信側） |
| jsQR | QRコード認識（受信側） |

これらのライブラリは最新版をインライン化による完全オフライン化を行う。
最新版に更新できるようなmakeコマンドを作成する

---

## 3. 共通プロトコル仕様

### 3.1 概要

QRチャネルを除く5つのチャネルは、以下の共通ビットレベルプロトコルを使用する。QRチャネルはQRコード自体のエラー訂正に依存する。

### 3.2 フレーム構造

```
[パイロット信号] → [ギャップ] → [プリアンブル] → [開始マーカー] → [データ長] → [データ本体] → [チェックサム]
```

| フィールド | サイズ | 値 | 説明 |
|------------|--------|-----|------|
| パイロット信号 | 700 ms | チャネル依存 | 通信開始の検出用 |
| ギャップ | 300 ms | 無信号 | パイロットとデータの境界 |
| プリアンブル | 8 bits | `10101010` | クロック同期用 |
| 開始マーカー | 8 bits | `11111111` | データ開始の確定マーカー |
| データ長 | 8 bits | 0–200 | データ本体のバイト数 |
| データ本体 | N × 8 bits | UTF-8バイト列 | メッセージ本文 |
| チェックサム | 8 bits | XOR | 全データバイトの排他的論理和 |

### 3.3 エンコード手順

1. メッセージ文字列をUTF-8でバイト列に変換する
2. バイト数が200を超える場合はエラーとする（最大200バイト制限）
3. 全バイトのXORを計算しチェックサムとする
4. ビット列を以下の順で構築する:
   - プリアンブル: `10101010`
   - 開始マーカー: `11111111`
   - データ長: 8ビット（MSBファースト）
   - データ本体: 各バイトを8ビット（MSBファースト）で展開
   - チェックサム: 8ビット（MSBファースト）

### 3.4 デコード手順

1. 受信したビット列から8個連続の1（`11111111`）を探し、開始マーカーとする
2. 開始マーカーの直後8ビットからデータ長を読み取る
3. データ長分のバイトを読み取る
4. 次の8ビットをチェックサムとして読み取る
5. データバイトのXORがチェックサムと一致するか検証する
6. 一致すればUTF-8としてデコードし、メッセージ文字列を返す
7. 不一致ならチェックサムエラーとする

### 3.5 グリッドチャネル用フレーミング

グリッドチャネルのみ、ビット単位プロトコルの代わりにバイト単位のフレーミングを使用する（2.6節参照）。これはグリッドが1フレーム16ビットの並列送信であり、ビット単位のプリアンブル/開始マーカーが不要なためである。

---

## 4. ビット受信ステートマシン（共通）

### 4.1 概要

音声系2チャネルと視覚系2チャネル（明滅・色変調）は、共通のビット受信ステートマシン（BitReceiver）を使用する。

### 4.2 状態遷移

```
idle → pilot → gap → bits → idle（デコード成功/失敗後）
```

| 状態 | 遷移条件 | 動作 |
|------|----------|------|
| `idle` | パイロット検出関数がtrueを返す | `pilot`へ遷移 |
| `pilot` | パイロット検出関数がfalseに変わる | `gap`へ遷移、ギャップ開始時刻を記録 |
| `gap` | ギャップ開始から GAP_MS × 0.6 以上経過 | `bits`へ遷移 |
| `bits` | bitMs + guardMs 間隔でビット判定関数を呼び出し、ビットを蓄積 | 必要ビット数が揃ったらデコード |
| `bits` | デコード成功 | メッセージコールバックを呼びidleへ |
| `bits` | デコード失敗（チェックサムエラー） | エラーコールバックを呼びidleへ |
| `bits` | 蓄積ビット数が2000を超える | タイムアウトとしてidleへ |

### 4.3 ポーリング方式

`requestAnimationFrame`を使用し、各フレームで状態に応じた処理を実行する。ビット受信中のサンプリングタイミングはperformance.now()で管理する。

---

## 5. 画面構成・UI仕様

### 5.1 全体レイアウト

モバイルファーストの縦型シングルページアプリケーション。最大幅480px、100dvhの高さで構成する。

```
┌─────────────────────────┐
│ ヘッダー                 │ ← 固定、チャネル選択
├─────────────────────────┤
│                         │
│ チャットエリア            │ ← スクロール可能
│                         │
├─────────────────────────┤
│ シグナルパネル            │ ← 展開/折畳み可能
├─────────────────────────┤
│ コントロール              │ ← 固定、入力・送信・受信
└─────────────────────────┘
```

### 5.2 ヘッダー

- アプリ名の表示
- 6つのチャネル選択ボタンを横並びで配置する（横スクロール/折り返し対応）
- アクティブなチャネルはハイライト表示する
- チャネル切替時に受信中であれば自動的に受信を停止する

### 5.3 チャットエリア

- メッセージを時系列で表示するエリア（上が古い、下が新しい）
- 新しいメッセージ追加時に自動スクロールする
- メッセージの種類:
  - **送信メッセージ**: 右寄せ、送信者側の色調で表示
  - **受信メッセージ**: 左寄せ、受信者側の色調で表示
  - **システムメッセージ**: 中央寄せ、控えめな色で表示
- 各メッセージには以下のメタ情報を表示する:
  - 送信/受信の区別
  - 使用したチャネル名
  - タイムスタンプ（HH:MM:SS）

### 5.4 シグナルパネル

送信中・受信中の信号をビジュアライズするパネル。

- **collapsed**: 高さ0、非表示
- **open**: 高さ180px、音声チャネル受信時や送信時に使用
- **expanded**: 高さ260px、視覚チャネル（カメラ映像表示）に使用
- パネル上部にチャネル名とステータスメッセージを表示する
- パネル内にCanvas要素を配置し、チャネルに応じたビジュアライゼーションを描画する:
  - 音声チャネル: FFTスペクトラム棒グラフ
  - 視覚チャネル: カメラのリアルタイム映像
  - 送信中（音声）: 波形アニメーション + プログレスバー

### 5.5 コントロールエリア

- テキスト入力フィールド（placeholder: 「メッセージを入力...」）
- 送信ボタン: テキスト入力があり、送信中・受信中でない場合のみ有効
- 受信モードトグルボタン:
  - 受信停止中: 「🎧 受信モード」と表示
  - 受信中: 「⏹ 受信停止」と表示、スタイル変更
- Enterキーでの送信をサポートする

### 5.6 全画面オーバーレイ

視覚系チャネルの送信時に使用する全画面表示レイヤー。

- 画面全体を覆うCanvasを配置する
- 右上にキャンセルボタンを配置する
- 下部中央に現在の送信ステータスを表示する
- 送信完了後に自動的に閉じる

---

## 6. 操作フロー

### 6.1 メッセージ送信

1. ユーザーがチャネルを選択する
2. テキスト入力欄にメッセージを入力する
3. 送信ボタンを押す（またはEnterキー）
4. 入力欄がクリアされ、チャットエリアに送信メッセージが追加される
5. チャネルに応じた物理信号の送信が開始される:
   - 音声チャネル: シグナルパネルが開き、波形アニメーションを表示
   - 視覚チャネル: 全画面オーバーレイが表示され、画面全体で信号を送出
6. 送信完了後、シグナルパネル/オーバーレイが自動的に閉じる

### 6.2 メッセージ受信

1. ユーザーがチャネルを選択する
2. 「🎧 受信モード」ボタンを押す
3. 必要なメディアデバイス（マイクまたはカメラ）のパーミッションを要求する
4. シグナルパネルが展開され、ビジュアライゼーションが開始される
5. パイロット信号を検出したら「singnaling...」を表示する
6. データ受信中は「receiving...」を表示する
7. デコード成功時:
   - チャットエリアに受信メッセージを追加する
   - 「success!」を表示する
   - 受信モードを継続し、次のメッセージを待機する
8. デコード失敗時:
   - 「fail!」を表示する
   - 受信モードを継続し、次のメッセージを待機する
9. 「stop!」ボタンを押すと受信を終了し、メディアデバイスを解放する

### 6.3 チャネル切替

1. 受信中にチャネルを切り替えた場合、現在の受信を自動停止する
2. メディアデバイスを解放する
3. チャットエリアにシステムメッセージとして新しいチャネル名と説明を表示する
4. シグナルパネルを折り畳む

---

## 7. 非機能要件

### 7.1 パフォーマンス

- 受信中のポーリングは`requestAnimationFrame`を使用し、メインスレッドのブロッキングを最小限にする
- カメラ映像のピクセルサンプリングは間引き処理（例: 2ピクセルおき、16ピクセルおき等）を行い、CPU負荷を抑える
- 音声のFFT解析はAnalyserNodeのハードウェアアクセラレーションを活用する

### 7.2 リソース管理

- 送信完了時にAudioContextを適切にclose()する
- 受信停止時にMediaStreamの全トラックをstop()し、マイク・カメラを確実に解放する
- チャネル切替時に前チャネルのリソースを必ず解放する

### 7.3 エラーハンドリング

| エラー | 対処 |
|--------|------|
| メディアデバイスのパーミッション拒否 | ステータスにエラーメッセージを表示し、受信モードを解除する |
| メッセージが200バイトを超過 | 送信前にエラーを表示し、送信をブロックする |
| チェックサム不一致 | ステータスにエラーを表示し、受信モードを継続する |
| ビット受信のタイムアウト（2000ビット超過） | ステータスにタイムアウトを表示し、受信状態をリセットする |

### 7.4 セキュリティ

- HTTPS環境でのホスティングが必須（getUserMediaの要件）
- ユーザーの明示的な操作（ボタン押下）によってのみメディアデバイスにアクセスする
- 受信したメッセージをDOMに挿入する際はXSS対策としてテキストノードまたはtextContentを使用する

### 7.5 アクセシビリティ

- 各ボタンに適切なラベルをつける
- 送信ボタンの無効状態を視覚的に明確にする
- ステータスメッセージを画面上に常に表示し、現在の状態を把握できるようにする

---

## 8. 技術スタック

### 8.1 基本方針

- **シングルHTMLファイル**: 全てのHTML/CSS/JavaScriptを1ファイルに収める
- **フレームワーク不使用**: Typescript v5.9.3で依存ゼロで実装しjsにbuild
- **ビルドツール不使用**: そのままブラウザで動作する

### 8.2 外部依存

| ライブラリ | バージョン | 用途 |
|------------|------------|------|
| jsQR | 1.4.0 | QRコード認識 |
| qrcode-generator | 1.4.4 | QRコード生成 |

### 8.3 使用するブラウザAPI一覧

| API | 用途 |
|-----|------|
| Web Audio API（AudioContext, OscillatorNode, AnalyserNode） | 音声の生成・解析 |
| MediaDevices.getUserMedia({ audio }) | マイクアクセス |
| MediaDevices.getUserMedia({ video }) | カメラアクセス |
| Canvas 2D API | 映像の描画・ピクセル解析・信号の可視化 |
| requestAnimationFrame | 受信ポーリング・アニメーション |
| TextEncoder / TextDecoder | UTF-8のエンコード/デコード |
| performance.now() | 高精度タイミング管理 |

---

## 9. テスト方針

### 9.1 単体テスト対象

- Protocol.encode(): メッセージ → ビット列の変換が正しいこと
- Protocol.decode(): ビット列 → メッセージの変換が正しいこと
- Protocol.decode(): チェックサム不一致時にnullを返すこと
- Protocol.decode(): 開始マーカーが見つからない場合にnullを返すこと
- Protocol.encode() → Protocol.decode() のラウンドトリップが成功すること
- ASCII、日本語（マルチバイト）、絵文字での動作確認

### 9.2 結合テスト

2台のスマートフォンを用意し、各チャネルについて以下を手動で検証する:

| テスト項目 | 確認内容 |
|------------|----------|
| 短いメッセージ（英字5文字） | 正常に送受信できること |
| 日本語メッセージ | UTF-8マルチバイトが正しく扱われること |
| 最大長メッセージ（200バイト） | 正常に送受信できること |
| ノイズ環境 | 周囲が騒がしい/明るい環境での受信成功率 |
| 連続送信 | 1つ目の受信後、続けて2つ目を受信できること |
| チャネル切替 | 受信中にチャネルを切り替えてリソースが正しく解放されること |

---

## 10. 将来の拡張候補

以下は本バージョンのスコープ外だが、将来のバージョンで検討する機能を記す。

- 多周波同時変調（OFDM）による音声チャネルの高速化
- チャープ変調（Chirp Spread Spectrum）による長距離・高ノイズ耐性チャネル
- 複数メッセージの自動分割送信（200バイト超対応）
- メッセージの暗号化（事前共有鍵方式）
- 端末間のクロック同期によるグリッドチャネルの精度向上
- PWA化（ホーム画面追加、全画面表示）
- 送信者識別（ニックネーム設定とメッセージへの埋め込み）

---

## 付録A. チャネル性能の参考値

実測値ではなく、設計上の理論値。実環境では端末のスピーカー/マイク/カメラ特性および周囲環境に大きく依存する。

| チャネル | 理論ビットレート | 「こんにちは」(15バイト)の送信時間（目安） |
|----------|------------------|------------------------------------------|
| 超音波 | ~9.3 bps | 約17秒 |
| 可聴音 | ~12.8 bps | 約12秒 |
| 画面明滅 | ~4.0 bps | 約40秒 |
| 色変調 | ~3.6 bps | 約45秒 |
| 空間グリッド | ~40 bps | 約4秒 |
| QR | バースト（一括） | 約3秒（表示時間固定） |

※ 送信時間にはプリアンブル・開始マーカー・チェックサム・パイロット・ギャップの時間を含む。

---

## 付録B. 用語集

| 用語 | 説明 |
|------|------|
| FSK (Frequency Shift Keying) | 周波数の切り替えでビットを表現する変調方式 |
| パイロット信号 | 通信の開始を受信側に知らせるための固定周波数/パターンの信号 |
| プリアンブル | データの直前に置かれるクロック同期用のビットパターン |
| チェックサム | データの誤りを検出するために付加される検証値 |
| AnalyserNode | Web Audio APIのノードで、音声信号のFFT解析を行う |
| FFT (Fast Fourier Transform) | 時間領域の信号を周波数領域に変換する高速アルゴリズム |
| GATT | Generic Attribute Profile。BLEの通信プロファイル |
| BitReceiver | 本アプリで定義するビット受信の汎用ステートマシンクラス |
| ガード区間 | ビット間の干渉を防ぐための短い無信号期間 |
| キャリブレーション | 受信開始時に環境の基準値を測定し、閾値を動的に設定すること |